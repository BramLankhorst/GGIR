---
title: "Sensor fusion in GGIR"
author: "Vincent van Hees"
date: "February 09 2021"
output:
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: true
urlcolor: blue
vignette: >
  %\VignetteIndexEntry{Sensor fusion in GGIR}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
header-includes:
  - \usepackage{titling}
  - \pretitle{\begin{center}
    \includegraphics[]{GGIR-MASTERLOGO-RGB.png}\LARGE\\}
  - \posttitle{\end{center}}
---

# Introduction

Wearable sensors that combine tri-axial accelerometers with tri-axial gyroscope are becoming increasingly more feasible.
GGIR was origally developed for accelerometer-only applications. The availability of gyroscope data makes it possible to more accurately separate gravitational from movement-related acceleration during dynamic conditions.

To extract this information we need to combine the accelerometer and the gyroscope signals, this is called sensor fusion.
There are various approaches to this, most of which focus on a full kinematic description of the movement.

In my exploration of what approach to use I listed a couple of criteria:
- Algorithm needs to be fast as GGIR is designed to work with multi-days recordings.
- The primary focus for GGIR would be to quantify acceleration. A more elaborate kinematic description of orientation relative to the poles feels less essential given the typical use-cases GGIR.

Next, I explored some of the available algorithms such as the one by Luinge and Veltink from 2005, and the one proposed by Madgewick from 2009 (https://x-io.co.uk/open-source-imu-and-ahrs-algorithms/). However, II struggled to get to a fast implementation in R and struggled to go from their output to an estimate of the gravitational acceleration within the local coordinate system. Some of these issues may be related to my lack of skills on this topic.


So, I decided to build my own algorithm tailored to the needs of GGIR. You could see this as a starting point for GGIR to facilitate sensor fusion. So, I welcome contributions to help speed up this algorithm and/or replace it by more accurate algortihms. 

In this paper I have tried to document the algorithm as I have implemented it in function separategravity.

# Algorithm description

## Input

acc - A three column matrix with the accelerometer values in g-units.
gyr - A three column matrix with the gyroscope values in radians per second.
sf - sample frequency

## Coordinate system

All calculations will be done within the local coordinate system of the sensor.
In contrast to other algorithms I am not attempting to calculate roll, pitch or yaw, because
calculating those would require transitioning between multiple coordinate systems. For example, pitch derived from a gyroscope is always in a local coordinate system, while pitch derived from an accelerometer is always relative to the orientation of gravity. So, to me it does not sound logical to use those as starting point. Instead, I will derive the orientation of gravity relative to the local coordinate system and use the angular velocity relative to the local coordinate system to move the direction of gravity during movement. By tracking the orientation of gravity I will be able to subtract gravity from the acceleratomer, with local gravity-free acceleration as output.

## Angular velocity vector

The gyroscope signals represent angular velocity per sensor axis. From these we can derive a angular velocity vector with a magnitude (theta) and orientation vector (OV), which is a unit vector with three coordinates. 

```{R,eval=FALSE}
theta = sqrt(rowSums(gyr ^ 2)) # magnitude of theta (angular velocity)
OV = matrix(0, N, 3) # N is number of samples.
nozero = which(theta > 0)
OV[nozero,] = as.numeric(gyr[nozero,] / theta[nozero])

Next, we devided theta by the sample frequency because we want it to reflect orientation change per time stamp, not per second.

theta = theta / sf
```

## Derivation of fusion weights

First, I split the acceleration signals in a low- and a high-frequency component.
The low-pass filter component will be used later on as indicator of accelerometer orientation during static (non-movement periods).
The high-pass filter component we will use here to create weights to help us decide whether to rely more on accelerometer or gyroscope data.

```{R,eval=FALSE}
lb = 0.5 # cut-off frequency for the filter in Hertz
lowpf = signal::butter(n=4,c(lb/(sf/2)),type=c("low")) #creating filter coefficients
acc_lf = acc_hf = matrix(NA, nrow(acc), ncol(acc)) # initialize matrices
for (i in 1:3) {
    # note: acc_lf will also be used as assume orientation of gravity in the
    # absence of movement further down, so this calculate serves two purposes
    acc_lf[,i] <- signal::filter(lowpf, acc[,i]) # low-pass filtered
}
acc_hf <- acc - acc_lf # high-pass filtered
```

The weight vector is initialized as weight = 1 rely on gyroscope (default).

```{R,eval=FALSE}
  weight = rep(1, N)
```

When the summaed acceleration of the three axis is higher than 0.04g the weight=0 and the algorithm will rely more on the gyroscope..
However, the following code builds in a minor ramp from 0.04 to 0.05. The idea behind the 0.04g is that it should represent the combined noise of the three acceleration axis.

```{R,eval=FALSE}
  weight = pmin(pmax((rowSums(abs(acc_hf)) - 0.04),0) / 0.01, 1) 
```

### Maximum weight value.

By setting the maximum weight value to 1-(1/sf),
we ensure that there is always negative exponential shift from gyroscope based
orientation to accelerometer based orientation. This to counteract a
possible drift in the gyroscope derived orientation, and assuming that even under
dynamic circumstances the low-pass filtered accelerometer can provide a
crude estimate of the average orientation of the sensor across multiple seconds.

```{R,eval=FALSE}
maxweight = 1-(1/sf)
weight = ifelse(weight > maxweight, yes = maxweight, no = weight)
```


### Minimum non-zero weight value.

By setting a minimum non-zero weight value to 0.01, we ensure that when the gyro contribution is small it is ignored. This then speeds
up the algorithm, because the vector rotation does not have to be applied weight = ifelse(weight < 0.01, yes = 0, no = weight)


## Rotation vector

Fuse the acc and gyr signal:
acc_lf is the low-pass filter acceleration signals, and therefore 
our best estimate of the orientation of gravity within the local coordinate
system of sensor when the sensor is not moving.

In the following lines I calculate values gvector,
which is initialized as equal to acc_lf but rotated with the gyroscope information
relative to orientation of gravity in the preceding timestep if there is movement.
Now I will use theta and OV to rotate acc_lf, but proportional to amount of rotation

```{R,eval=FALSE}
  # This equation is standard geometric computation
  # https://stackoverflow.com/questions/6721544/circular-rotation-around-an-arbitrary-axis
  RotArr = array(dim = c(N, 3, 3)) # this is a rotation matrix for every timestep
  costheta = cos(theta)
  sintheta = sin(theta)
  RotArr[,1,1:3] = cbind(costheta +
                           OV[,1]^2 * (1-costheta), OV[,1] * OV[,2] * (1- costheta) -
                           OV[,3] * sintheta, OV[,1] * OV[,3] * (1- costheta) +
                           OV[,2] * sintheta)
  RotArr[,2,1:3] = cbind(OV[,2] * OV[,1] * (1- costheta) +
                           OV[,3] * sintheta, costheta +
                           OV[,2]^2 * (1-costheta),OV[,2] * OV[,3] * (1- costheta) -
                           OV[,1] * sintheta)
  RotArr[,3,1:3] = cbind(OV[,3] * OV[,1] * (1- costheta) -
                           OV[,2] * sintheta, OV[,3] * OV[,2] * (1- costheta) +
                           OV[,1] * sintheta,  costheta +
                           OV[,3]^2 * (1-costheta))
```
  
## Rotating the graviation vector

In the follow lines I loop over the non-zero weight values to rotate the gravitational vector
within the local coordinate system. Note that this is an iterative process: Each step depends on previous step,
by which it difficult to speed this up.  

```{R,eval=FALSE}
gvector = acc_lf # initialize gvector as equivalent of acc_lf
weight_not_zero = which(weight > 0)
if (weight_not_zero[1] == 1) weight_not_zero = weight_not_zero[2:length(weight_not_zero)]
for (j in weight_not_zero) {
  gvector[j,] = (crossprod(RotArr[j-1,,],  gvector[j-1,]) * weight[j]) + (acc_lf[j,] * (1-weight[j]))
}
acclocal = acc - gvector
```


# Performance


## Speed

...


## Accurate

...
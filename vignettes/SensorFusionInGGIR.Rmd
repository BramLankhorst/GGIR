---
title: "Sensor fusion in GGIR"
author: "Vincent van Hees"
date: "February 13 2021"
output:
   html_document:
    toc : true
    number_sections: true
    toc_depth: 3
    toc_float: true #by turning this on, the table of contents moves to the left of the page.
urlcolor: blue
vignette: >
  %\VignetteIndexEntry{Sensor fusion in GGIR}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r, echo=FALSE, out.width = "100%", out.extra='style="border: 0; padding:20px"'}
knitr::include_graphics("GGIR-MASTERLOGO-RGB.png")
```

# Introduction

Wearable sensors that combine acceleration and gyroscope sensors have existed for decades but have only recently become feasible for use in population research. This research field requires that the wearable sensors are worn for at least a week, while high resolution data is being logged for later offline analysis. R package [GGIR](https://CRAN.R-project.org/package=GGIR) originated from the need to process accelerometer-only data in the 2010s. However, with the new availability of gyroscope data it is important that GGIR is expanded to also facilitate gyroscope data.

For health researchers with no background in sensor technology it may be good to point out that a gyroscope sensor measures angular velocity. This information can help us to achieve a more accurate estimation of sensor's magnitude of acceleration and orientation. You may not be aware of this, but accelerometer-only applications have always had the fundamental limitation that they were poor at distinguishing acceleration caused by gravity and acceleration caused by movement while the sensor is moving and rotating relative to gravity. See also the work by my colleagues and I in our [2013 PLOSONE publication](link to pa(https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0061691).

Extracting the improved estimate of acceleration and orientation is a non-trivial task as we need to combine information from both the acceleration- and gyroscope signals, typically referred to as sensor fusion.

# Requirements

I identified the following criteria for doing sensor fusion GGIR :
- The algorithm should be fast enough to process a week worth of 100 Hertz sensor data. A couple of minutes is fine, but it would be unacceptable if the processing takes hours.
- The primary focus for GGIR is to quantify acceleration related to movement via improved separation of the gravitational signal component. A more elaborate kinematic description including estimates of Eular angles seems less essential within the context of GGIR.

# Initial exploration of existing algorithms

Various sensor fusion algorithms have been proposed in the literature. As I have not specific backgroun in this, I spent a couple of days exploring the algorithms proposed by Luinge and Veltink in 2005, and the one proposed by [Madgewick in 2009](https://x-io.co.uk/open-source-imu-and-ahrs-algorithms/). However, I struggled to get them to run within an R environment at an acceptable speed. Further, I found it difficult to translate their output to an estimate of local (gravity free) acceleration. As this has only been a side project for me, I decided to develop my own algorithm tailored to the needs of GGIR. In this way I challenged myself to learn about this topic and it allowed me to make a starting point with facilitating sensor fusion in GGIR. GGIR is an open-source project, so I welcome help and financial support to develop and improve this functionality. Please get in touch if you are interested: v.vanhees@accelting.com.

# Algorithm description

## Input

The input of the algorithm consists of three objects: `acc`, a three-column matrix with the accelerometer values in *g*-units; `gyr`, a three-column matrix with the gyroscope values in radians per second, and; `sf` the sample frequency in Hertz. The algorithm assumes a constant sample frequency throughout the recording. Please note that GGIR has function `resample` to aid in converting irregularly sampled data to a regular sample frequency.

## Coordinate system

All calculations will be done within the local coordinate system of the sensor. In contrast to other algorithms I encounted online I am not attempting to calculate roll, pitch or yaw, because calculating those would require transitioning between multiple coordinate systems. For example, pitch derived from a gyroscope is in a local coordinate system, while pitch derived from an accelerometer is relative to the orientation of gravity. Instead, I will derive the orientation of gravitational acceleration relative to the local coordinate system of the sensor and use the angular velocity relative to the local coordinate system to rotate the orientation of the gravity vector during movement. By tracking the orientation of gravity within the local coordinate system of the sensor I will be able to subtract gravity from the acceleration signals.

## Angular velocity vector

The gyroscope signals represent angular velocity in radians per second. As I want to rotate the gravitational acceleration vector, I need to split the gyroscope signals up in an angular velocity vector with a magnitude (`theta` in the code) per time step and 3 coordinates for the vector orientation (object `OV` in the code) relative to the sensors coordinate system. 

```{R,eval=FALSE}
theta = sqrt(rowSums(gyr ^ 2)) # theta (magnitude of angular velocity around orientation vector OV)
OV = matrix(0, N, 3) # N is number of samples.
nozero = which(theta > 0)
OV[nozero,] = as.numeric(gyr[nozero,] / theta[nozero])
```

Next, theta is divided by the sample frequency to get radians per time step.

```{R,eval=FALSE}
theta = theta / sf
```

## Derivation of fusion weights

Weights are used to decide for each time step the extent to which we want to rely on the accelerometer or on the gyroscope for gravity orientation assessment. For this I am using the high-frequency component of the signal as indicator of movement. However, later on I will need a low-pass filtered signal as indicator of gravity orientation during static (non-movement periods). So, to safe computational time I apply a low-pass filter and subtract it from the original signal to get the high-pass filtered signals.

```{R,eval=FALSE}
lb = 0.5 # cut-off frequency for the filter in Hertz
lowpf = signal::butter(n=4,c(lb/(sf/2)),type=c("low")) #creating filter coefficients
acc_lf = acc_hf = matrix(NA, nrow(acc), ncol(acc)) # initialize matrices
for (i in 1:3) {
    # note: acc_lf will also be used as assume orientation of gravity in the
    # absence of movement further down, so this calculate serves two purposes
    acc_lf[,i] <- signal::filter(lowpf, acc[,i]) # low-pass filtered
}
acc_hf <- acc - acc_lf # high-pass filtered
```

Weights are expressed on a scale between 0 and 1, where 0 indicates full dependence on accelerometer, and 1 indicates full dependence on gyroscope. When the summed acceleration of the three axes is less than 0.04g the weight is set to 0. The threshold of 0.04g reflects the assumed combined noise of the three acceleration signals. The following code has a built-in ramp from 0.04 to 0.05. When the summed acceleration is above 0.05 the weight is set to 1. 

```{R,eval=FALSE}
weight = pmin(pmax((rowSums(abs(acc_hf)) - 0.04),0) / 0.01, 1) 
```

### Maximum weight value

By setting the maximum weight value to 1-(0.5/sf) I ensure that there is always a negative exponential drift from gyroscope estimate to the accelerometer estimate. This to counteract a possible drift in the gyroscope derived orientation change. Here, I am making the assumption that even under dynamic circumstances the low-pass filtered acceleration signal averaged across multiple seconds provides some indication of the average orientation of the sensor during that period.


```{R,eval=FALSE}
maxweight = 1-(0.5/sf)
weight = ifelse(weight > maxweight, yes = maxweight, no = weight)
```


### Minimum non-zero weight value

By setting a minimum non-zero weight value to 0.01, and rounding all values below 0.01 to 1, I ensure make that the fusion is skipped when the gyroscope contribution is small. This to speed up the algorithm.

```{R,eval=FALSE}
weight = ifelse(weight < 0.01, yes = 0, no = weight)
```

## Rotation vector

To rotate the orientation vector of gravity we need to convert `theta` and `OV` into a rotation matrix.

Note that this is a standard textbook procedure:
https://stackoverflow.com/questions/6721544/circular-rotation-around-an-arbitrary-axis 

```{R,eval=FALSE}
  RotArr = array(dim = c(N, 3, 3)) # this is a rotation matrix for every timestep
  costheta = cos(theta)
  sintheta = sin(theta)
  RotArr[,1,1:3] = cbind(costheta +
                           OV[,1]^2 * (1-costheta), OV[,1] * OV[,2] * (1- costheta) -
                           OV[,3] * sintheta, OV[,1] * OV[,3] * (1- costheta) +
                           OV[,2] * sintheta)
  RotArr[,2,1:3] = cbind(OV[,2] * OV[,1] * (1- costheta) +
                           OV[,3] * sintheta, costheta +
                           OV[,2]^2 * (1-costheta),OV[,2] * OV[,3] * (1- costheta) -
                           OV[,1] * sintheta)
  RotArr[,3,1:3] = cbind(OV[,3] * OV[,1] * (1- costheta) -
                           OV[,2] * sintheta, OV[,3] * OV[,2] * (1- costheta) +
                           OV[,1] * sintheta,  costheta +
                           OV[,3]^2 * (1-costheta))
```
  
## Rotating the gravity vector

In the following lines I loop over the non-zero weight values to rotate the gravitational vector
within the local coordinate system. Note that this is an iterative process, each step depends on the previous step, which is why I am using a loop and not an `apply` statement in R. If you have suggestions on how I could speed this up then I would love to hear from you.

```{R,eval=FALSE}
gvector = acc_lf # initialize gvector as equivalent of acc_lf
weight_not_zero = which(weight > 0)
if (weight_not_zero[1] == 1) weight_not_zero = weight_not_zero[2:length(weight_not_zero)]
for (j in weight_not_zero) {
  gvector[j,] = (crossprod(RotArr[j-1,,],  gvector[j-1,]) * weight[j]) +
    (acc_lf[j,] * (1-weight[j]))
}
acclocal = acc - gvector
```

# Using the algorithm with GGIR

At the moment I have implemented the functionality only for the .cwa data collected with AX6 sensors by Axivity Ltd.
To use the functionality apply GGIR function `g.shell.GGIR` to the .cwa file as you would do with accelerometer-only data and the code will automatically use the gyroscope data. For the moment it only extracts metric `sgAccEN` as epoch level summary of the data, which represents the epoch level average of the magnitude of acceleration after separation of the gravitational component. To skip the procedure set argument do.sgAccEN = FALSE.

# Reflections on performance and next steps

The `separategravity` function is able to process 24 hours of 100 Hertz data in 30 seconds (Ubuntu 20, 8 core, 16GB), which seems promising. I have been doing some simple home experiments to get a initial idea of whether the algorithm provides plausible output. For example, by swinging the AX6 like a pendulum in the vertical plane and trying to keep track of it's angle with gravity. However, a thorough benchmark test has not been done yet. If you are interested in doing or supporting such work then please let me know: v.vanhees@accelting.com. I also welcome suggestions and support for implementing alternative fusion algorithms in GGIR.


```{r, echo=FALSE, out.width = "75%", out.extra='style="border: 0; padding:20px"'}
knitr::include_graphics("GGIR-MASTERLOGO-RGB.png")
```